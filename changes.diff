diff --git a/source/projects/pyext/pyext.c b/source/projects/pyext/pyext.c
index 3438b3d..c93bd09 100644
--- a/source/projects/pyext/pyext.c
+++ b/source/projects/pyext/pyext.c
@@ -10,6 +10,78 @@
 t_class* pyext_class = NULL;
 static bool pyext_py_initialized = false;
 
+// ----------------------------------------------------------------------------
+// PyextOutlet - Simple outlet wrapper for pyext
+// We define our own instead of using pktpy's Outlet to avoid conflicts
+
+typedef struct {
+    void* outlet;  // Max outlet pointer
+} PyextOutlet;
+
+static py_Type g_pyext_outlet_type = 0;
+
+// PyextOutlet.int(value)
+static bool pyext_outlet_int(int argc, py_Ref argv) {
+    PY_CHECK_ARGC(1);
+    PY_CHECK_ARG_TYPE(0, tp_int);
+
+    PyextOutlet* self = py_touserdata(py_arg(-1));
+    py_i64 value = py_toint(py_arg(0));
+
+    if (self->outlet) {
+        outlet_int(self->outlet, (long)value);
+    }
+
+    py_newnone(py_retval());
+    return true;
+}
+
+// PyextOutlet.float(value)
+static bool pyext_outlet_float(int argc, py_Ref argv) {
+    PY_CHECK_ARGC(1);
+
+    PyextOutlet* self = py_touserdata(py_arg(-1));
+    double value = 0.0;
+
+    if (py_isint(py_arg(0))) {
+        value = (double)py_toint(py_arg(0));
+    } else if (py_isfloat(py_arg(0))) {
+        value = py_tofloat(py_arg(0));
+    } else {
+        return TypeError("expected int or float");
+    }
+
+    if (self->outlet) {
+        outlet_float(self->outlet, value);
+    }
+
+    py_newnone(py_retval());
+    return true;
+}
+
+// PyextOutlet.bang()
+static bool pyext_outlet_bang(int argc, py_Ref argv) {
+    PY_CHECK_ARGC(0);
+
+    PyextOutlet* self = py_touserdata(py_arg(-1));
+
+    if (self->outlet) {
+        outlet_bang(self->outlet);
+    }
+
+    py_newnone(py_retval());
+    return true;
+}
+
+// Register PyextOutlet type
+static void pyext_register_outlet_type() {
+    g_pyext_outlet_type = py_newtype("PyextOutlet", tp_object, NULL, NULL);
+
+    py_bindmethod(g_pyext_outlet_type, "int", pyext_outlet_int);
+    py_bindmethod(g_pyext_outlet_type, "float", pyext_outlet_float);
+    py_bindmethod(g_pyext_outlet_type, "bang", pyext_outlet_bang);
+}
+
 // ----------------------------------------------------------------------------
 // ext_main - external setup
 
@@ -57,6 +129,9 @@ t_max_err pyext_init(t_pyext* x)
         // Initialize API module
         api_module_initialize();
 
+        // Register our PyextOutlet type
+        pyext_register_outlet_type();
+
         pyext_py_initialized = true;
         post("pyext: pocketpy initialized");
     }
@@ -231,17 +306,15 @@ t_max_err pyext_load_script(t_pyext* x, t_symbol* script_name)
         goto error;
     }
 
-    x->py_instance = py_retval();
+    // Store instance in a dedicated register to prevent it being overwritten
+    // We use register 10 as a dedicated storage for the instance
+    py_Ref instance_storage = py_getreg(10);
+    py_assign(instance_storage, py_retval());
+
+    x->py_instance = instance_storage;
     x->py_class_type = py_typeof(x->py_instance);
 
-    // Debug: Test if we can set an attribute
-    py_Ref test_val = py_getreg(0);
-    py_newint(test_val, 999);
-    bool can_set = py_setattr(x->py_instance, py_name("_test_attr"), test_val);
-    object_post((t_object*)x, "DEBUG: py_setattr test = %s", can_set ? "SUCCESS" : "FAILED");
-    if (!can_set) {
-        py_printexc();
-    }
+    object_post((t_object*)x, "DEBUG: stored instance in register 10, type=%d", py_typeof(x->py_instance));
 
     // Query for inlets and outlets count using py_getdict (direct __dict__ access)
     // This bypasses property lookups and gets the actual instance variable
@@ -334,14 +407,17 @@ t_max_err pyext_inject_outlets(t_pyext* x)
     py_Ref outlets_list = py_getreg(0);
     py_newlistn(outlets_list, x->num_outlets);
 
-    // Populate the list with Outlet objects
+    // Populate the list with PyextOutlet objects
     for (long i = 0; i < x->num_outlets; i++) {
         py_Ref outlet_item = py_list_getitem(outlets_list, i);
 
-        // Create Outlet wrapper object
-        OutletObject* outlet_obj = py_newobject(outlet_item, g_outlet_type, 0, sizeof(OutletObject));
-        outlet_obj->outlet = x->outlets[i];
-        outlet_obj->owns_outlet = false;  // Don't free - owned by Max object
+        // Create PyextOutlet object with userdata
+        PyextOutlet* outlet_obj = py_newobject(outlet_item, g_pyext_outlet_type, 0, sizeof(PyextOutlet));
+        if (outlet_obj) {
+            outlet_obj->outlet = x->outlets[i];
+        } else {
+            object_error((t_object*)x, "failed to allocate PyextOutlet for outlet %ld", i);
+        }
     }
 
     // Set the outlets_list attribute on the Python instance
@@ -375,15 +451,19 @@ t_max_err pyext_call_method_noargs(t_pyext* x, const char* method_name)
         return MAX_ERR_NONE;
     }
 
-    py_GlobalRef method = py_retval();
-    if (!py_callable(method)) {
+    py_GlobalRef unbound_func = py_retval();
+    if (!py_callable(unbound_func)) {
         // Not callable - not an error
         return MAX_ERR_NONE;
     }
 
-    // Call the method - push unbound method and instance as first argument
-    py_push(method);
-    py_push(x->py_instance);  // Pass instance explicitly
+    // Create a bound method explicitly (use register 1, not 0)
+    py_Ref bound_method = py_getreg(1);
+    py_newboundmethod(bound_method, x->py_instance, unbound_func);
+
+    // Call the bound method
+    py_push(bound_method);
+    py_pushnil();  // nil for self since it's a bound method
     bool ok = py_vectorcall(0, 0);
 
     if (!ok) {
@@ -419,18 +499,34 @@ t_max_err pyext_call_method(t_pyext* x, const char* method_name,
         return MAX_ERR_NONE;
     }
 
-    py_GlobalRef method = py_retval();
+    py_GlobalRef unbound_func = py_retval();
 
-    if (!py_callable(method)) {
+    if (!py_callable(unbound_func)) {
         // Not callable - not an error
         return MAX_ERR_NONE;
     }
 
-    // Setup call - push unbound method and instance as first argument
-    py_push(method);
-    py_push(x->py_instance);  // Pass instance explicitly
+    // Debug: check types before creating bound method
+    py_Type inst_type = py_typeof(x->py_instance);
+    py_Type func_type = py_typeof(unbound_func);
+    object_post((t_object*)x, "DEBUG: instance type=%d (tp_function=%d), func type=%d",
+                inst_type, tp_function, func_type);
+    object_post((t_object*)x, "DEBUG: are they the same object? %s",
+                (x->py_instance == unbound_func) ? "YES" : "NO");
+
+    // Create a bound method explicitly (use register 1, not 0)
+    py_Ref bound_method = py_getreg(1);
+    py_newboundmethod(bound_method, x->py_instance, unbound_func);
+
+    // Debug: verify bound method was created correctly
+    object_post((t_object*)x, "DEBUG: bound_method type=%d (should be %d)",
+                py_typeof(bound_method), tp_boundmethod);
+
+    // Setup call with bound method
+    py_push(bound_method);
+    py_pushnil();  // nil for self since it's a bound method
 
-    // Convert arguments
+    // Convert arguments (use register 0 for temp values)
     for (long i = 0; i < argc; i++) {
         py_Ref r0 = py_getreg(0);
         switch (atom_gettype(argv + i)) {
